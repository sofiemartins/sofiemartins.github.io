<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geometry of Field Data in Memory &mdash; HiRep  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Global Objects" href="global_objects.html" />
    <link rel="prev" title="Auto-Generation of Macros" href="auto_generation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> HiRep
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to_cite.html">How to cite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/input_file.html">Input File Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/supported_features.html">Supported Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/analysis.html">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/writing_programs.html">Writing A Program in HiRep</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="coding_conventions.html">Coding Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing_setup.html">Testing Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_generation.html">Auto-Generation of Macros</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Geometry of Field Data in Memory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#geometry-properties">Geometry Properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometry-descriptor">Geometry Descriptor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#global-geometry-descriptors">Global Geometry Descriptors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#number-of-sites">Number of Sites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#master-pieces">Master Pieces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inner-master-pieces">Inner Master Pieces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-arrangement-in-memory">Block Arrangement in Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#openmp">OpenMP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-communications">Optimizing Communications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-synchronization">Buffer Synchronization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#field-operations">Field Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#even-odd-decomposition">Even-Odd Decomposition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cpu">CPU</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#contingency">Contingency</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spinor-fields">Spinor Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauge-fields">Gauge Fields</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="global_objects.html">Global Objects</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="../../doxygen/build/html/index.html#http://">Full Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HiRep</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Geometry of Field Data in Memory</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/development_manual/field_geometry.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="geometry-of-field-data-in-memory">
<h1>Geometry of Field Data in Memory<a class="headerlink" href="#geometry-of-field-data-in-memory" title="Permalink to this headline"></a></h1>
<section id="geometry-properties">
<h2>Geometry Properties<a class="headerlink" href="#geometry-properties" title="Permalink to this headline"></a></h2>
<p>Fields living on the four-dimensional lattice are defined to be C arrays of elements using the data structures in the corresponding section. The geometry of the lattice is defined by assigning an index <img class="math" src="../_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> of the array to each site <img class="math" src="../_images/math/41bbe18ba2e7c788ee3e8001476eb6c130016c48.png" alt="(t, x, y, z)"/>. The mapping between the cartesian coordinates of the local lattice and the array index is given by the macros <code class="docutils literal notranslate"><span class="pre">iup(n,dir)</span></code> and <code class="docutils literal notranslate"><span class="pre">idn(n,dir)</span></code> which, given the index <img class="math" src="../_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> of the current site, return the index of the site whose cartesian coordinate in direction <code class="docutils literal notranslate"><span class="pre">dir</span></code> is increased or decreased by one respectively.</p>
<section id="geometry-descriptor">
<h3>Geometry Descriptor<a class="headerlink" href="#geometry-descriptor" title="Permalink to this headline"></a></h3>
<p>In the MPI version of the code the lattice is broken up into local lattices in addition to an even-odd preconditioning forming blocks of data in memory. Each of these blocks then corresponds to a contiguous set of indices. As a result, we need to additionally allocate field memory for buffers that we can use to send and receive information between different cores and nodes. In order to communicate correctly, we need to first fill the buffer of data to be sent. The division of the local lattice into blocks, the location of the different buffers and buffer copies are described in the following C structure in <code class="docutils literal notranslate"><span class="pre">Include/geometry.h</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_geometry_descriptor</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inner_master_pieces</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">local_master_pieces</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">total_spinor_master_pieces</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">total_gauge_master_pieces</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">master_start</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">master_end</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">master_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ncopies_spinor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ncopies_gauge</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">copy_from</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">copy_to</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">copy_len</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">copy_shift</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nbuffers_spinor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nbuffers_gauge</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">rbuf_len</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">sbuf_len</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">rbuf_from_proc</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rbuf_start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">sbuf_to_proc</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">sbuf_start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">gsize_spinor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">gsize_gauge</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fuse_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fuse_gauge_size</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fuse_inner_counter</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">geometry_descriptor</span><span class="p">;</span><span class="w"></span>

</pre></div>
</div>
<section id="global-geometry-descriptors">
<h4>Global Geometry Descriptors<a class="headerlink" href="#global-geometry-descriptors" title="Permalink to this headline"></a></h4>
<p>Usually, we want to initialize fields either on the full lattice or only with even or odd parity. In order to do this efficiently, the global geometry descriptors <code class="docutils literal notranslate"><span class="pre">glattice</span></code>, <code class="docutils literal notranslate"><span class="pre">glat_even</span></code> and <code class="docutils literal notranslate"><span class="pre">glat_odd</span></code> are initialized globally on host memory. These can then be used to allocate fields correspondingly</p>
</section>
<section id="number-of-sites">
<h4>Number of Sites<a class="headerlink" href="#number-of-sites" title="Permalink to this headline"></a></h4>
<p>In order to allocate memory for the field data, we need to know how many elementary field types we need to allocate. This is different for fields that are located on the sites or the links of the lattice. Correspondingly, for the given lattice geometry, the number of sites and the number of links are calculated and saved in the fields <code class="docutils literal notranslate"><span class="pre">gsize_spinor</span></code> and <code class="docutils literal notranslate"><span class="pre">gsize_gauge</span></code> respectively.</p>
</section>
<section id="master-pieces">
<h4>Master Pieces<a class="headerlink" href="#master-pieces" title="Permalink to this headline"></a></h4>
<p>A piece is called <em>master</em> if it does not contain copies of other sites, as for example is the case for buffer pieces. These are copies of sites already stored in a master piece.</p>
<p>The sites in a master piece can be categorized by their function in computation and communications.</p>
<ul class="simple">
<li><p>Bulk elements/inner elements</p>
<ul>
<li><p>Function in computation: Computation performed on bulk elements does not need communication because the sites in the bulk only depend on sites on the boundary, which are already accessible from the thread.</p></li>
<li><p>Function in communication: No sites any of the local lattices in other threads depend on the sites in the bulk of this lattice, they do not need to be communicated.</p></li>
</ul>
</li>
<li><p>Boundary Sites, which are sites located on the boundary of the local block</p>
<ul>
<li><p>Function in computation: The boundary element need to be calculated separately from the bulk, because they depend on sites in the extended lattice and these elements need to be communicated first.</p></li>
<li><p>Function in communication: Boundary elements of a local lattice are halo elements of another. As a result, they need to be communicated.</p></li>
</ul>
</li>
<li><p>Halo Elements/Receive buffers, the bulk and boundary plus halo form the extended lattice.</p>
<ul>
<li><p>Function in computation: Halo elements are only accessible to the thread in order to perform the calculations on the boundary, usually, we do not want to perform calculations on the halo. One exception, however, is, if the computation is faster than the communication, it might be easier to perform the operations on the extended lattices without communication, rather than only computing for bulk and boundary and then synchronize the extension.</p></li>
<li><p>Function in communication: We synchronize the extended lattice by writing to it so that this data is available to the current thread, but never read from and communicate the extended lattice somewhere else.</p></li>
</ul>
</li>
</ul>
<p>The following figure depicts these categories of sites on a two-dimensional <img class="math" src="../_images/math/7d2f024350ab68a5b592d4e0946351f3399aeef2.png" alt="4\times 4"/>-lattice.</p>
<a class="bg-primary reference internal image-reference" href="../_images/bulk_boundary_halo.png"><img alt="Illustration of bulk boundary and halo sites on a 2D lattice" class="bg-primary align-center" src="../_images/bulk_boundary_halo.png" style="width: 400px;" /></a>
<p>A single boundary communication between two 2D local lattices would accordingly work as in the following illustration</p>
<a class="bg-primary reference internal image-reference" href="../_images/comms.png"><img alt="Communication between to 2D local lattice blocks" class="bg-primary align-center" src="../_images/comms.png" style="width: 400px;" /></a>
<p>Here the boundary elements are being communicated to the respective boundary of the other block. Bulk elements are unaffected.</p>
</section>
<section id="inner-master-pieces">
<h4>Inner Master Pieces<a class="headerlink" href="#inner-master-pieces" title="Permalink to this headline"></a></h4>
<p>The first decomposition of the lattice site is the even-odd preconditioning. This splits  any lattice in two pieces: an even and an odd one. These pieces are stored contiguously in memory meaning that at the first indices one can only read sites of the even lattice and after an offset we are only reading odd sites. For an even-odd preconditioned lattice the number of inner master pieces is therefore two and can be accessed in the variable <code class="docutils literal notranslate"><span class="pre">inner_master_pieces</span></code> of the geometry descriptor. In this context, an <em>inner</em> master piece comprises all sites that are in the <em>bulk</em> of a local lattice of given parity.</p>
<p>Resultingly, there is a shift in the local master piece block that is the starting index of the odd sites. For this, one can use the field <code class="docutils literal notranslate"><span class="pre">master_shift</span></code>. This field contains the offset of a lattice geometry relative to the full lattice. The even lattice is not offset and overlaps with the first half of the full lattice. The odd lattice, however, overlaps with the last half, so it is offset by half the number of lattice points compared to the full lattice. As a result, the odd lattice geometry, saved in the global variables as <code class="docutils literal notranslate"><span class="pre">&amp;glat_odd</span></code> has the <code class="docutils literal notranslate"><span class="pre">master_shift</span></code> agreeing with the first index of the odd block of the full lattice.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">shift_full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glattice</span><span class="o">-&gt;</span><span class="n">master_shift</span><span class="w"> </span><span class="cm">/* = 0 */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">shift_even</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glat_even</span><span class="o">-&gt;</span><span class="n">master_shift</span><span class="w"> </span><span class="cm">/* =0 */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">shift_odd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glat_odd</span><span class="o">-&gt;</span><span class="n">master_shift</span><span class="w"> </span><span class="cm">/* not 0, index of first odd entry */</span><span class="w"></span>
</pre></div>
</div>
<p>which corresponds to a full lattice being decomposed like the following illustration:</p>
<a class="bg-primary reference internal image-reference" href="../_images/eo_linear.png"><img alt="Illustration of Decomposition of 1D Array into Even and Odd Sites" class="bg-primary align-center" src="../_images/eo_linear.png" style="width: 400px;" /></a>
<section id="local-master-pieces">
<h5>Local Master Pieces<a class="headerlink" href="#local-master-pieces" title="Permalink to this headline"></a></h5>
<p>The local master pieces are the pieces of local lattices, the blocks that the lattice is decomposed into to be processed either by a single thread/core or GPU. For example, take a lattice of size <img class="math" src="../_images/math/aa0143141ad01212258f431bae9acf434acd752b.png" alt="8^3\times 16"/> split up with an MPI layout of <code class="docutils literal notranslate"><span class="pre">1.1.1.2</span></code> into two local lattices of size <img class="math" src="../_images/math/342b98565de0b6727ec2394fe055319c4fcbf6b1.png" alt="8^4"/>. Due to the even-odd preconditioning the blocks are further split up into two. The field <code class="docutils literal notranslate"><span class="pre">local_master_pieces</span></code> identifies the number of local master pieces. In this case the integer saved in <code class="docutils literal notranslate"><span class="pre">local_master_pieces</span></code> is equal to four. This is saved in memory in the following way: First the even parts of the two blocks and then the odd parts.</p>
<a class="bg-primary reference internal image-reference" href="../_images/eo_block_decomp.png"><img alt="Combination of Even-Odd-Preconditioning and Block Decomposition in Memory" class="bg-primary align-center" src="../_images/eo_block_decomp.png" style="width: 400px;" /></a>
</section>
<section id="total-master-pieces">
<h5>Total Master Pieces<a class="headerlink" href="#total-master-pieces" title="Permalink to this headline"></a></h5>
<p>Additionally, the geometry descriptor contains two numbers of <em>total master pieces</em>, one for spinors and one for gauge fields. This counts the number of local master pieces plus the number of receive buffers, but not send buffers. This is exactly the extended lattice in the directions that are parallelized, i.e. the global lattice is split in this direction. Iterating over the total number of master pieces equates therefore to an iteration over the local lattices including their halo regions.</p>
<p>The number of interfacing elements does not only depend on this decomposition but also whether the saved field is saved on the lattice links or sites. Consequently, while the master pieces are identical, the buffer structure depends on whether the field that needs to be communicated is a gauge field or a spinor field. For this, the geometry descriptor contains both an integer for the total number of master pieces for a spinor field and the total number of master pieces for a gauge field. Additionally, there are fields that contain corresponding counts of buffers for both field geometries, <code class="docutils literal notranslate"><span class="pre">nbuffers_spinor</span></code> and <code class="docutils literal notranslate"><span class="pre">nbuffers_gauge</span></code>.</p>
</section>
</section>
<section id="block-arrangement-in-memory">
<h4>Block Arrangement in Memory<a class="headerlink" href="#block-arrangement-in-memory" title="Permalink to this headline"></a></h4>
<p>In order to work with the block structure efficiently and optimize memory access patterns, the sites belonging to a single piece are stored consecutively in memory. Since the field data is stored in a one-dimensional array, we can access the sites stored in a block by consecutive indices. As a result, in order to access all sites in a block, we need to know the index where it starts and where it ends. This information is stored in the arrays <code class="docutils literal notranslate"><span class="pre">master_start</span></code> and <code class="docutils literal notranslate"><span class="pre">master_end</span></code>.</p>
<p>Here, every block is identified by an index, in the code often called <code class="docutils literal notranslate"><span class="pre">ixp</span></code>. The mapping of the index to the block is persistent but arbitrary and therefore subject to convention. In memory, and correspondingly at site index level, the blocks are stored such that first there is a large block of field data of local lattices with even parity and then with odd parity. However, at block index level, the even <code class="docutils literal notranslate"><span class="pre">ixp</span></code> identify even lattices and odd <code class="docutils literal notranslate"><span class="pre">ixp</span></code> odd lattices, with lattices of two parities belonging to the same local lattices adjacent. This means for example, that if the even part of my local lattice is stored at <code class="docutils literal notranslate"><span class="pre">ixp=4</span></code>, then the odd part can be found at <code class="docutils literal notranslate"><span class="pre">ixp=5</span></code>. For a simple decomposition into two blocks with even-odd preconditioning are arranged in memory as in the following illustration</p>
<a class="bg-primary reference internal image-reference" href="../_images/ixp_numbering.png"><img alt="Block Index Assignment Illustration" class="bg-primary align-center" src="../_images/ixp_numbering.png" style="width: 400px;" /></a>
<p>with block indices being assigned in a non-contingent way described above.</p>
<p>In order to find the starting index of a piece with index 5 belonging to a decomposed spinor field, one would write</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">spinor_field</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* initialize a field */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">index_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">master_start</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>One could find out the length of the block, which is not necessarily constant, by writing the following</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">block_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">master_start</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">master_end</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="openmp">
<h4>OpenMP<a class="headerlink" href="#openmp" title="Permalink to this headline"></a></h4>
<p>The integers</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fuse_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fuse_gauge_size</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fuse_inner_counter</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>are necessary for optimizing communications between cores on a single node.</p>
</section>
<section id="optimizing-communications">
<h4>Optimizing Communications<a class="headerlink" href="#optimizing-communications" title="Permalink to this headline"></a></h4>
<p>As already described the local blocks decompose further into even and odd pieces, sites of the halo, boundary and bulk. We want to access these pieces separately, because they have different roles in computation and communication. Manipulating these different elements in the field data therefore requires different code. However, in order to conserve optimal access patterns, every data access has to be an access to a single block of contiguous memory. When storing all sites in the extended lattice naively, one might have to access multiple blocks of memory for a particular computation or communication step. This negatively impacts memory access performance due to suboptimal bus-utilization, data reuse and automatic caching patterns. The challenge is, therefore, to arrange the sites in memory in such a way that every memory access is an access to a single continguous block of memory.</p>
<p>As a result, we want to store the data in a local block first of all in such a way, that the inner sites are all consecutive, are then followed by boundary elements and finally halo elements/receive buffers.</p>
<section id="boundary-and-receive-buffers">
<h5>Boundary and Receive Buffers<a class="headerlink" href="#boundary-and-receive-buffers" title="Permalink to this headline"></a></h5>
<p>Here in particular the arrangement of the boundary elements is crucial, because different overlapping parts of the boundary are requested by different nodes. At this point, we do not need to worry about the concrete arrangement of points in the bulk, because computations on the inner points can be executed in a single block, a caveat being discussed in the next section.</p>
<p>We arrange memory as in the following 4-by-4 2D example</p>
<a class="bg-primary reference internal image-reference" href="../_images/contingent_numbering.png"><img alt="Example Of Contingent Numbering" class="bg-primary align-center" src="../_images/contingent_numbering.png" style="width: 400px;" /></a>
<ul class="simple">
<li><p>The lattice is decomposed into an even and an odd part, which are contiguous in memory respectively. The first index with an odd entry, the master shift of the odd lattice, is 17.</p></li>
<li><p>The bulk consists for each sublattice of only two sites. Sites 0-1 and 17-18 are the inner sites of the even and odd lattice respectively.</p></li>
<li><p>We do not need to consider the edges of the square in the extended lattice, because they are not used in any computations, since they are not neighbors to any of the sites in the local lattice.</p></li>
<li><p>For the even lattice we walk around the inner sites to label the boundary elements. If this local lattice is parallelized in both dimensions, then we need to exchange all boundary elements with other nodes. 2-3 with another node, then 4-5 and then 5-6. These three memory accesses do no pose a problem, since they are continguous. However, the next send buffer will try to access elements 7 and 2. These are not contiguous. As a result, we have to allocate space for site 2 twice, so that we can copy it, to a site with index 8. We have to make sure that whenever we need this information, it is in sync with the information stored at site 2.</p></li>
<li><p>We can now proceed to label the receive buffers. Here we want the memory that we write to again be contiguous. This works out naturally, the receive buffers are 9-10, then 11-12, then 13-14 and finally 15-16.</p></li>
<li><p>Proceed analogously for the odd lattice. In contrast to the even lattice, we do not have any holes in the numbering.</p></li>
</ul>
</section>
<section id="bulk-arrangement">
<h5>Bulk Arrangement<a class="headerlink" href="#bulk-arrangement" title="Permalink to this headline"></a></h5>
<p>As mentioned above, inner elements are always accessed as a block in memory and therefore the accesses are continguous. However, the order of access can have an impact on L1 and L2 caching and therefore the speed of memory transfer. Caching is optimal, if the bulk elements are subdivided into smaller block elements. This is implemented under the name <em>path blocking</em>. The dimensions of the bulk subblocks are stored in the global variables (<code class="docutils literal notranslate"><span class="pre">Include/global.h</span></code>)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*path blocking size*/</span><span class="w"></span>
<span class="n">GLB_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">PB_T</span><span class="p">,</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">GLB_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">PB_X</span><span class="p">,</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">GLB_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">PB_Y</span><span class="p">,</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">GLB_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">PB_Z</span><span class="p">,</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>as <code class="docutils literal notranslate"><span class="pre">PB_T</span></code>, <code class="docutils literal notranslate"><span class="pre">PB_X</span></code>, <code class="docutils literal notranslate"><span class="pre">PB_Y</span></code> and <code class="docutils literal notranslate"><span class="pre">PB_Z</span></code>. On a 6-by-6 2D lattice <code class="docutils literal notranslate"><span class="pre">PB_X=2</span></code> and <code class="docutils literal notranslate"><span class="pre">PB_Y=2</span></code> would imply a decomposition as in the following illustration</p>
<a class="bg-primary reference internal image-reference" href="../_images/path_blocking.png"><img alt="Path Blocking Illustration" class="bg-primary align-center" src="../_images/path_blocking.png" style="width: 200px;" /></a>
</section>
</section>
<section id="buffer-synchronization">
<h4>Buffer Synchronization<a class="headerlink" href="#buffer-synchronization" title="Permalink to this headline"></a></h4>
<p>For complex decompositions, that are usual in lattice simulations, the blocks have to communicate in a highly non-trivial way. For example decomposing a <img class="math" src="../_images/math/d3ab5fbaf0fa0d38a6a90f7c54abf4d3d549316c.png" alt="32^3\times 64"/> lattice into <img class="math" src="../_images/math/342b98565de0b6727ec2394fe055319c4fcbf6b1.png" alt="8^4"/> local lattices requires 512 processes to communicate the three dimensional surfaces of each four-dimensional local lattice with all interfacing blocks. In order to perform this communication we need to know both the indices of the sending blocks and map them to the receiving blocks. This information is stored in the arrays <code class="docutils literal notranslate"><span class="pre">rbuf_from_proc</span></code> and <code class="docutils literal notranslate"><span class="pre">sbuf_to_proc</span></code>, which tell us which processes send to which processes by id, and further the arrays <code class="docutils literal notranslate"><span class="pre">rbuf_start</span></code> and <code class="docutils literal notranslate"><span class="pre">sbuf_start</span></code>, which tell us at which index in the local lattice we need to start reading. We can iterate through these arrays to find pairs of sending and receiving processes and perform the communication. The size of the memory transfer is further stored in the array <code class="docutils literal notranslate"><span class="pre">sbuf_len</span></code> and <code class="docutils literal notranslate"><span class="pre">rbuf_len</span></code>.</p>
<p>The number of copies necessary depends on whether the field is a spinor field or gauge field and saved in the fields <code class="docutils literal notranslate"><span class="pre">nbuffers_spinor</span></code> and <code class="docutils literal notranslate"><span class="pre">nbuffers_gauge</span></code>.</p>
</section>
</section>
</section>
<section id="field-operations">
<h2>Field Operations<a class="headerlink" href="#field-operations" title="Permalink to this headline"></a></h2>
<section id="even-odd-decomposition">
<h3>Even-Odd Decomposition<a class="headerlink" href="#even-odd-decomposition" title="Permalink to this headline"></a></h3>
<section id="cpu">
<h4>CPU<a class="headerlink" href="#cpu" title="Permalink to this headline"></a></h4>
<p>A sufficiently local operator only operates on the site value and its nearest neighbors.
As a result, we can decompose the operation into a step that can be executed site by site and is therefore diagonal and another step where every site only depends on the nearest neighbors. This we can further decompose into two steps, one acting on the even lattice sites while the odd sites are frozen and then another step acting on the odd lattice sites while the even ones are frozen. As a result, this decomposition enables us to effectively evaluate local operators on the lattice because it can be done in parallel, using multiple CPU cores or GPUs.
In order to efficiently work with this decomposition on the CPU and the GPU, the even and odd sites are stored in separate blocks on the lattice. This means for the CPU that for a field that is defined on both even and odd sites, one can easily iterate through the even sites by iterating through the first half of the allocated memory.</p>
<p>For example, for spinor fields, iterating through the even sites mechanically works as in the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lattice_volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="o">*</span><span class="n">Z</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lattice_volume</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We only iterate through half the lattice points. Iterating through the odd sites requires us to know the offset at which the odd indices begin. All information regarding lattice geometry is stored in the geometry descriptor.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lattice_volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="o">*</span><span class="n">Z</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glat_odd</span><span class="o">-&gt;</span><span class="n">master_shift</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lattice_volume</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In practice, the programmer should not be forced to think about lattice geometry. For this, the corresponding for loops are replaced by the macros <code class="docutils literal notranslate"><span class="pre">_PIECE_FOR</span></code>, <code class="docutils literal notranslate"><span class="pre">_SITE_FOR</span></code> and <code class="docutils literal notranslate"><span class="pre">_MASTER_FOR</span></code> that are defined in <code class="docutils literal notranslate"><span class="pre">Include/geometry.h</span></code>.</p>
<section id="master-for">
<h5>_MASTER_FOR<a class="headerlink" href="#master-for" title="Permalink to this headline"></a></h5>
<p>This macro iterates over all sites without considering which piece they are located. For example, for the spinor field, this would simplify to</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate spinor that is defined on all sites</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_MASTER_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="o">+</span><span class="n">ix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Take <img class="math" src="../_images/math/e4762cec46619bf7781cae62216214f909395368.png" alt="V"/> to be the number of lattice sites. Then <code class="docutils literal notranslate"><span class="pre">ix</span></code> runs from 0 to <img class="math" src="../_images/math/14d39e801dee9fa5eb814517b55d4e53ebcfae1d.png" alt="V-1"/>. If the lattice geometry is given as even, it runs from 0 to <img class="math" src="../_images/math/179906fd841bdbd4487d2d2fd0b1e05301bd20c2.png" alt="\tfrac{V}{2}-1"/>. If it is odd, it runs from <img class="math" src="../_images/math/3efea5b29687de740b5d7cd3546de00167368fe5.png" alt="\tfrac{V}{2}"/> to <img class="math" src="../_images/math/14d39e801dee9fa5eb814517b55d4e53ebcfae1d.png" alt="V-1"/>. It is possible to iterate over an even spinor in the following way</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate even spinor</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_MASTER_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="o">+</span><span class="n">ix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Nevertheless, iterating over an odd spinor the same way will yield a segmentation fault. This is because, in the odd spinor, only the odd sites are allocated starting at 0. As a result, we need to iterate from 0 to <img class="math" src="../_images/math/179906fd841bdbd4487d2d2fd0b1e05301bd20c2.png" alt="\tfrac{V}{2}-1"/> for the odd spinor. This, however, clashed with the fact that if we have a spinor that is defined on all lattice sites, we want to have the indices start at <img class="math" src="../_images/math/3efea5b29687de740b5d7cd3546de00167368fe5.png" alt="\tfrac{V}{2}"/>. \par
To solve this problem, instead of accessing the elements directly, there is a macro that correctly accesses given a global index provided by either <code class="docutils literal notranslate"><span class="pre">_SITE\_FOR</span></code> or <code class="docutils literal notranslate"><span class="pre">_MASTER_FOR</span></code>: <code class="docutils literal notranslate"><span class="pre">_FIELD_AT</span></code> in <code class="docutils literal notranslate"><span class="pre">Include/spinor_field.h</span></code>.
The right way to iterate over any geometry is to use the following pattern, with the corresponding geometry substituted in the allocation function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate odd spinor</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glat_odd</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_MASTER_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_FIELD_AT</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">_PIECE_FOR</span></code> Depending on the operation we need to perform on the field, we might need to know whether we are currently operating on the even or the odd part of the field. Leaving aside MPI decomposition, which will be explained later, the field is decomposed into only two pieces: The odd and the even part. If the spinor is only odd or even and there is no further MPI decomposition, there will be only a single piece. An index labels the pieces often called <code class="docutils literal notranslate"><span class="pre">ixp</span></code> in the order they appear in memory. Therefore (without any MPI decomposition), the even part has the index <code class="docutils literal notranslate"><span class="pre">ixp</span></code>=0, and the odd part <code class="docutils literal notranslate"><span class="pre">ixp</span></code>=1.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_PIECE_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Operating on piece: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">_SITE_FOR</span></code> We can now decompose the <code class="docutils literal notranslate"><span class="pre">_MASTER_FOR</span></code> into <code class="docutils literal notranslate"><span class="pre">_PIECE_FOR</span></code> and <code class="docutils literal notranslate"><span class="pre">_SITE_FOR</span></code>. This might be necessary if we want to iterate over the sites and always have the information on which piece we are currently operating.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_PIECE_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_SITE_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Operating on piece %d at index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="gpu">
<h5>GPU<a class="headerlink" href="#gpu" title="Permalink to this headline"></a></h5>
<p>We will not want to use any for-loop macros to iterate over the sites on the GPU. Instead, we want to distribute the operations on the sites over different threads. Further, in anticipation of a later MPI decomposition, any kernel operation on the fields should launch a separate kernel for each piece. At the point of a simple even-odd decomposition, we need to do the following:</p>
<ul class="simple">
<li><p>Wrap the kernel call in <code class="docutils literal notranslate"><span class="pre">_PIECE_FOR</span></code>. This will take care of any block decomposition identically to the CPU.</p></li>
<li><p>Only pass the odd or even block to the kernel at the correct offset. The global thread/block index will then be used to iterate over the sites, and we do not need to worry about any global indices. All the kernel knows about is the block. This serves as a replacement of <code class="docutils literal notranslate"><span class="pre">_SITE_FOR</span></code>.</p></li>
<li><p>Read out the field value for a given local block index having only the offset starting pointer at hand. Due to the special memory structure discussed in the next section, this has to be done using the GPU reading, and writing functions declared in <code class="docutils literal notranslate"><span class="pre">Include/suN.h</span></code>. These serve as a replacement to <code class="docutils literal notranslate"><span class="pre">_FIELD_AT</span></code>. They are not completely analogous because, depending on the structure, they do not read out the complete site. For the spinor field, for example, the reading must be done spinor component-wise.</p></li>
</ul>
<p>For a spinor field in the fundamental representation, one would use the function <code class="docutils literal notranslate"><span class="pre">read_gpu_suNf_vector</span></code> because the components of the spinor are vectors, and it is necessary to read the spinor vector-wise. Further, to only pass the block the kernel is supposed to operate on, we are using the macro <code class="docutils literal notranslate"><span class="pre">_GPU_FIELD_BLK</span></code> in <code class="docutils literal notranslate"><span class="pre">Include/gpu.h</span></code>. This macro takes the spinor field and the piece index <code class="docutils literal notranslate"><span class="pre">ixp</span></code> and returns the starting pointer of the local block in the GPU field data copy.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Define grid size and block size for kernel execution</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// number</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// number</span>

<span class="w">    </span><span class="c1">// Stride that separated even and odd sites in memory is half the</span>
<span class="w">    </span><span class="c1">// number of lattice points</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">vol4h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="o">*</span><span class="n">Z</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="o">/</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_spinor_field_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Piece for is used identically to the CPU</span>
<span class="w">    </span><span class="n">_PIECE_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Local block is passed using _GPU_FIELD_BLK</span>
<span class="w">        </span><span class="n">example_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">_GPU_FIELD_BLK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ixp</span><span class="p">),</span><span class="w"> </span><span class="n">vol4h</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">example_kernel</span><span class="p">(</span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vol4h</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Local index on the block</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">suNf_spinor</span><span class="o">*</span><span class="w"> </span><span class="n">site</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Only perform the operation if the index is on the block</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ix</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vol4h</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Read out the spinor component-wise</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">component</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">read_gpu_suNf_vector</span><span class="p">(</span><span class="n">vol4h</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">site</span><span class="p">).</span><span class="n">c</span><span class="p">[</span><span class="n">component</span><span class="p">],</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Reading an element of the gauge field is slightly different. We can transfer the loop over the different pieces, but since the gauge field is a vector field, we have more components to consider. Therefore we need to replace <code class="docutils literal notranslate"><span class="pre">_GPU_FIELD_BLK</span></code> with <code class="docutils literal notranslate"><span class="pre">_GPU_4FIELD_BLK</span></code>. For the gauge field the readout functions is simply <code class="docutils literal notranslate"><span class="pre">read_gpu_suNf</span></code>, which is also located in <code class="docutils literal notranslate"><span class="pre">suN.h</span></code>. This function reads out the vector component-wise.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;global.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN_types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geometry.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Define grid size and block size for kernel execution</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// number</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// number</span>

<span class="w">    </span><span class="c1">// Stride that separated even and odd sites in memory is half the</span>
<span class="w">    </span><span class="c1">// number of lattice points</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">vol4h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="o">*</span><span class="n">Z</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">suNf_field</span><span class="w"> </span><span class="o">*</span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_gfield_f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Piece for is used identically to the CPU</span>
<span class="w">    </span><span class="n">_PIECE_FOR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ixp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Local block is passed using _GPU_4FIELD_BLK</span>
<span class="w">        </span><span class="n">example_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">_GPU_4FIELD_BLK</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">ixp</span><span class="p">),</span><span class="w"> </span><span class="n">vol4h</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">example_kernel</span><span class="p">(</span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vol4h</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Local index on the block</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">suNf</span><span class="o">*</span><span class="w"> </span><span class="n">site</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Only perform the operation if the index is on the block</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ix</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vol4h</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">read_gpu_suNf</span><span class="p">(</span><span class="n">vol4h</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">site</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ix</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The writing functions work analogous.</p>
</section>
</section>
</section>
<section id="contingency">
<h3>Contingency<a class="headerlink" href="#contingency" title="Permalink to this headline"></a></h3>
<p>These reading and writing functions are necessary to access memory in a contingent way when performing operations on the fields. If we store the spinors in the same way they are stored on the CPU this will not be contingent. To understand the problem, we can look at the implementation of the inner product of two spinors at the kernel level.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;s1,s2&gt;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">COMPLEX</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">spinor_field_prod_gpu</span><span class="p">(</span><span class="n">COMPLEX</span><span class="o">*</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">COMPLEX</span><span class="o">*</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">hr_complex</span><span class="o">*</span><span class="w"> </span><span class="n">resField</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">resField</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_complex_prod</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In every thread we iterate over the components of the input arrays <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code>. Which are located at the same site. The different threads in this kernel now operate on the different sites of the lattice. Now, when this kernel is launched, the threads all try first to access all the first elements of all sites. However, when the sites are stored identically as on the CPU, this means that we access memory segments separated by a stride, as in the following illustration:</p>
<a class="bg-primary reference internal image-reference" href="../_images/11.png"><img alt="Illustration of a Non-Contingent Access of Vector Elements" class="bg-primary align-center" src="../_images/11.png" style="width: 300px;" /></a>
<p>We can optimize this significantly by not saving one site after another but instead saving first all first components, then all seconds components and so on in the order they are accessed in the loop.</p>
<a class="bg-primary reference internal image-reference" href="../_images/2.png"><img alt="Illustration of Contingent Access of Vector Elements" class="bg-primary align-center" src="../_images/2.png" style="width: 300px;" /></a>
<p>This means that memory is accessed contiguously as a single block. This is more efficient because it maximizes bus utilization and L1 cache hit rate.</p>
<section id="spinor-fields">
<h4>Spinor Fields<a class="headerlink" href="#spinor-fields" title="Permalink to this headline"></a></h4>
<p>At a code level, this is achieved by requesting the start pointer at a given index as usual, then performing a cast to the corresponding complex type and writing or reading from memory a stride away. For example, if one wanted to read out the second component of the first component vector of a spinor on the CPU, one would do that as follows</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;random.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">void</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">field</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">field</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">gaussian_spinor_field</span><span class="p">(</span><span class="n">field</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// For example</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ix</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Access second vector component of first spinor component</span>
<span class="w">    </span><span class="n">hr_complex</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>On the GPU, this would be done in the following way</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spinor_field.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;suN.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;random.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">void</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialize a random spinor field</span>
<span class="w">    </span><span class="n">spinor_field</span><span class="w"> </span><span class="o">*</span><span class="n">field</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">field</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_spinor_field_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glattice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">gaussian_spinor_field</span><span class="p">(</span><span class="n">field</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">spinor_field_copy_to_gpu_f</span><span class="p">(</span><span class="n">field</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Kernel launch parameters</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// plug in value</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// plug in value</span>

<span class="w">    </span><span class="c1">// The stride by which the components are separated</span>
<span class="w">    </span><span class="c1">// First we save the even sites component wise and then</span>
<span class="w">    </span><span class="c1">// the odd sites component wise.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="o">*</span><span class="n">Z</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">example_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">gpu_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">example_kernel</span><span class="p">(</span><span class="n">suNf_spinor</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Cast to a complex pointer. On the CPU start_as_complex++ would give us</span>
<span class="w">    </span><span class="c1">// the next component. Here we need to jump by a stride</span>
<span class="w">    </span><span class="n">hr_complex</span><span class="w"> </span><span class="o">*</span><span class="n">start_as_complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hr_complex</span><span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// We can read out the first component using the index, because the first</span>
<span class="w">    </span><span class="c1">// components are arranged in a block of complex numbers of half the</span>
<span class="w">    </span><span class="c1">// lattice size.</span>
<span class="w">    </span><span class="n">hr_complex</span><span class="w"> </span><span class="n">first_component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_as_complex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ix</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The second component is removed from the first component by the stride.</span>
<span class="w">    </span><span class="n">hr_complex</span><span class="w"> </span><span class="n">second_component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_component</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This shuffles how the <code class="docutils literal notranslate"><span class="pre">struct</span></code>s are organized in the previously allocated space.</p>
</section>
<section id="gauge-fields">
<h4>Gauge Fields<a class="headerlink" href="#gauge-fields" title="Permalink to this headline"></a></h4>
<p>For the gauge fields for every site, there are four link directions. Since the matrices stored on the links can be complex or real, the real and imaginary part of the matrices are additionally separated by a stride.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="auto_generation.html" class="btn btn-neutral float-left" title="Auto-Generation of Macros" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="global_objects.html" class="btn btn-neutral float-right" title="Global Objects" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>